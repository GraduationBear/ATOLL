@page "/graphique"

<div id="ensemble">
    <div id="haut">
        <select class="form-select form-select-sm" aria-label=".form-select-sm example" id="antenne" @bind="@this.selected" @onclick="SetTabRaw">
                @*Affichage des fichiers dans le menu déroulant*@
                @foreach (Antenne a in Graphique.ants.GetListe())
                {
                    <option value="@a.GetNom()">@a.GetNom()</option>
                }
            
        </select>
        <div id="onglets">
            <nav>
                @*Affichage du bouton en fonction du contexte*@
                @if (this.bo)
                {
                    <button class="btn btn-primary" @onclick="clickBtnChange">Polaire</button>
                }
                else
                {
                    <button class="btn btn-primary" @onclick="clickBtnChange">Cartesien</button>
                }
            </nav>
        </div>
    </div>
    <div id="tabgraph" class="border-top-0">
        <div id="table">
            

            @if (this.selected != null)
            {
                <table class="table table-bordered">
                    <thead>
                    <tr>
                        <th>AZ</th>
                        <th>Amp</th>
                        <th>Phase</th>
                    </tr>
                    </thead>
                    <tbody>
                    @*Affichage du tableau de données représentant le graphique à côté*@
                    @for(int i=0;i<tableauRaw.Count()-1;i++)
                    {
                        <tr>
                            <td><input @bind-value="@tableauRaw[i].X" @bind-value:event="onchange"></td>
                            <td><input @bind-value="@tableauRaw[i].Y" @bind-value:event="onchange"></td>
                            <td><input @bind-value="@tableauRaw[i].Z" @bind-value:event="onchange"></td> 
                        </tr>
                    }
                    </tbody>
                </table>
            }
        </div>
        <div id="chart">
            
            @*Affichage du graphique selectionné*@
            @if (this.bo & (this.selected != null))
            {
                <SfChart Title="@this.selected" Palettes="@palettes">
                    <ChartPrimaryXAxis Minimum="-180" Maximum="180" Interval="30" RangePadding="ChartRangePadding.Auto" CrossesAt="0"/>
                    <ChartPrimaryYAxis RangePadding="ChartRangePadding.Auto" Minimum="0" Maximum="1" CrossesAt="0"/>

                    <ChartSeriesCollection>
                        @if (this.selected != null)
                        {
                            <ChartSeries DataSource="@Graphique.TransformRawToCart(tableauRaw)" XName="X" YName="Y"/>
                        }
                        else
                        {
                            <ChartSeries XName="X" YName="Y"/>
                        }

                    </ChartSeriesCollection>
                </SfChart>
            }
            else if (!this.bo & (this.selected != null))
            {
                <SfChart Title="@this.selected" Palettes="@palettes">
                    <ChartPrimaryXAxis StartAngle="90" Minimum="0" Maximum="360" Interval="30"> </ChartPrimaryXAxis>
                    <ChartPrimaryYAxis Minimum="0" Maximum="1"/>
                    <ChartSeriesCollection>
                        <ChartSeries DataSource="@tableauRaw" XName="X" Width="2" Opacity="1" YName="Y"
                                     Type="ChartSeriesType.Polar" DrawType="ChartDrawType.Spline">

                        </ChartSeries>
                    </ChartSeriesCollection>
                </SfChart>
            }

        </div>
    </div>
</div>


@code {
    //Attribut TRUE : cartesien FALSE : polaire
    private bool bo = true;

    //Variable stockant toute les antennes du fichier Antennas
    private static Antennes ants = new Antennes();

    //Variable désignant l'antenne selectionnée
    private string selected = Graphique.ants.GetFirst().GetNom();

    //Liste des Points permettant l'affichage de l'Antenne "selected"
    private List<Point> tableauRaw;

    //Palette de couleur des graphiques
    public String[] palettes = new String[] { "#E94649", "#F6B53F", "#6FAAB0" };
    
    //Compteur pour savoir la ligne à modifier
    private int c = 0;
    private string text = "disabled";
    private bool enabled = false;

    //Modification activé/ pas activé 

    public void setEnabled()
    {
        if (!enabled)
        {
            this.enabled = !this.enabled;
        }
        if (enabled)
        {
            this.text = "";
        }
        else
        {
            this.text = "disabled";
        }
    }


    //Méthode s'activant à l'appui du boutton Polar/Cartesian
    public void clickBtnChange()
    {
        this.bo = !bo;
    }

    //Méthode se lancant au chargement de la page
    protected override void OnInitialized()
    {
        this.SetTabRaw();
    }


    //Permet de définir le tableauRaw des données
    public void SetTabRaw()
    {
        this.tableauRaw=Graphique.ants.SearchAntenneByName(selected).GetRawData();
    }


    //Méthode statique permettant de transformer les donées du format "raw" au format "cartesien"
    public static List<Point> TransformRawToCart(List<Point> init)
    {
        List<Point> Cart = new List<Point>();
        for (int i = 0; i < init.Count()-1;i++)
        {
            int milieu = (init.Count() - 1) / 2;
            if (i < milieu)
            {
                Cart.Add(new Point {X = init[i].GetX()-180, Y = init[milieu+i].GetY() , Z= init[milieu+i].GetZ()});
            }
            else
            {
                if (i == init.Count() - 2)
                {
                    Cart.Add(new Point {X = 180, Y = init[milieu].GetY(), Z = init[0].GetZ()});
                }
                else
                {
                    Cart.Add(new Point {X = init[i].GetX()-180, Y = init[i-milieu].GetY() , Z= init[i-milieu].GetZ()});
                }
            }
        }
        return Cart;
    }


    //Classe Antenne ayant un Nom, un Chemin et un Contenu
    //Une représentation "Raw" (données pures)
    //Une représentation cartesienne
    public class Antenne
    {
        //Attributs
        private string Nom { get; set; }
        private string Path { get; set; }
        private string[] Contenu { get; set; }
        
        private List<Point> RawData;
        private List<Point> ChartCartData;

        //Constructeur de la classe Antenne
        public Antenne(string nom, string path, string[] contenu)
        {
            this.Nom = nom;
            this.Path = path;
            this.Contenu = contenu;
            this.RawData = new List<Point>();
            this.ChartCartData = new List<Point>();
            
            //remplissage du tableau brut
            for (int i = 5; i < this.Contenu.Length - 1; i++)
            {

                string pattern = @"([0-9\.\S])+";
                Regex rgx = new Regex(pattern);
                string str = this.Contenu[i];
                var ci = (CultureInfo) CultureInfo.CurrentCulture.Clone();
                ci.NumberFormat.NumberDecimalSeparator = ".";

                double az = double.Parse(rgx.Matches(str)[0].Value);
                double amp = double.Parse(rgx.Matches(str)[1].Value, ci);
                double phase = double.Parse(rgx.Matches(str)[2].Value, ci);

                RawData.Add(new Point {X = az, Y = amp , Z= phase});

                if (i == this.Contenu.Length - 2)
                {
                    RawData.Add(new Point {X = 360, Y = RawData[0].GetY() , Z=phase});
                }
            }

            //Remplissage du tableau cartesien
            for (int i = 0; i < RawData.Count()-1;i++)
            {
                int milieu = (RawData.Count() - 1) / 2;
                if (i < milieu)
                {
                    ChartCartData.Add(new Point {X = RawData[i].GetX()-180, Y = RawData[milieu+i].GetY() , Z= RawData[milieu+i].GetZ()});
                }
                else
                {
                    if (i == RawData.Count() - 2)
                    {
                        ChartCartData.Add(new Point {X = 180, Y = RawData[milieu].GetY(), Z = RawData[0].GetZ()});
                    }
                    else
                    {
                        ChartCartData.Add(new Point {X = RawData[i].GetX()-180, Y = RawData[i-milieu].GetY() , Z= RawData[i-milieu].GetZ()});
                    }
                }
            }
        }

        public string GetNom()
        {
            return this.Nom;
        }

        public string GetPath()
        {
            return this.Path;
        }

        public string[] GetContent()
        {
            return this.Contenu;
        }

        public List<Point> GetRawData()
        {
            return this.RawData;
        }

        public List<Point> GetChartCartData()
        {
            return this.ChartCartData;
        }
    }


    //Classe Antennes : stocke les Antennes présente dans le dossier sous forme d'une liste d'antenne
    public class Antennes
    {

        private const string folderPath = @"C:\Users\DME\source\repos\ATOLL\ATOLL\Resources\Antennas\Antenna types";
        private List<Antenne> l { get; set; }
        
        
        //Constructeur de Antennes
        public Antennes()
        {
            
            DirectoryInfo place = new DirectoryInfo(folderPath);
            FileInfo[] files = place.GetFiles();
            this.l = new List<Antenne>();
            foreach(FileInfo file in files)
            {
                string filePath = folderPath + "\\" + file.Name;
                Antenne x = new Antenne(file.Name, filePath, System.IO.File.ReadAllLines(filePath));
                l.Add(x);
            }
            

        }

        //getter de la Liste
        public List<Antenne> GetListe()
        {
            return this.l;
        }

        //Méthode permettant de rechercher une antenne avec son Nom
        public Antenne SearchAntenneByName(string nom)
        {
            foreach(Antenne a in this.l)
            {
                if (a.GetNom() == nom)
                {
                    return a;
                }
            }
            return null;
        }

        public Antenne GetFirst()
        {
            return this.l[0];
        }
       
    }


    //Classe représentant les points X et Y du Graphique . Z représente la Phase
    public class Point
    {
        public double X { get; set;}
        public double Y { get; set; }
        public double Z { get; set; }

        public double GetX()
        {
            return this.X;
        }

        public double GetY()
        {
            return this.Y;
        }

        public double GetZ()
        {
            return this.Z;
        }
        public void SetX(double x)
        {
            this.X=x;
        }

        public void SetY(double y)
        {
           this.Y=y;
        }

        public void SetZ(double z)
        {
            this.Z=z;
        }
    }
}

  